// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Immich.Models
{
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    #pragma warning disable CS1591
    public partial class SystemConfigFFmpegDto : IAdditionalDataHolder, IParsable
    #pragma warning restore CS1591
    {
        /// <summary>The accel property</summary>
        public global::Immich.Models.TranscodeHWAccel? Accel { get; set; }
        /// <summary>The accelDecode property</summary>
        public bool? AccelDecode { get; set; }
        /// <summary>The acceptedAudioCodecs property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::Immich.Models.AudioCodec?>? AcceptedAudioCodecs { get; set; }
#nullable restore
#else
        public List<global::Immich.Models.AudioCodec?> AcceptedAudioCodecs { get; set; }
#endif
        /// <summary>The acceptedContainers property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::Immich.Models.VideoContainer?>? AcceptedContainers { get; set; }
#nullable restore
#else
        public List<global::Immich.Models.VideoContainer?> AcceptedContainers { get; set; }
#endif
        /// <summary>The acceptedVideoCodecs property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::Immich.Models.VideoCodec?>? AcceptedVideoCodecs { get; set; }
#nullable restore
#else
        public List<global::Immich.Models.VideoCodec?> AcceptedVideoCodecs { get; set; }
#endif
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>The bframes property</summary>
        public int? Bframes { get; set; }
        /// <summary>The cqMode property</summary>
        public global::Immich.Models.CQMode? CqMode { get; set; }
        /// <summary>The crf property</summary>
        public int? Crf { get; set; }
        /// <summary>The gopSize property</summary>
        public int? GopSize { get; set; }
        /// <summary>The maxBitrate property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? MaxBitrate { get; set; }
#nullable restore
#else
        public string MaxBitrate { get; set; }
#endif
        /// <summary>The preferredHwDevice property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? PreferredHwDevice { get; set; }
#nullable restore
#else
        public string PreferredHwDevice { get; set; }
#endif
        /// <summary>The preset property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Preset { get; set; }
#nullable restore
#else
        public string Preset { get; set; }
#endif
        /// <summary>The refs property</summary>
        public int? Refs { get; set; }
        /// <summary>The targetAudioCodec property</summary>
        public global::Immich.Models.AudioCodec? TargetAudioCodec { get; set; }
        /// <summary>The targetResolution property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? TargetResolution { get; set; }
#nullable restore
#else
        public string TargetResolution { get; set; }
#endif
        /// <summary>The targetVideoCodec property</summary>
        public global::Immich.Models.VideoCodec? TargetVideoCodec { get; set; }
        /// <summary>The temporalAQ property</summary>
        public bool? TemporalAQ { get; set; }
        /// <summary>The threads property</summary>
        public int? Threads { get; set; }
        /// <summary>The tonemap property</summary>
        public global::Immich.Models.ToneMapping? Tonemap { get; set; }
        /// <summary>The transcode property</summary>
        public global::Immich.Models.TranscodePolicy? Transcode { get; set; }
        /// <summary>The twoPass property</summary>
        public bool? TwoPass { get; set; }
        /// <summary>
        /// Instantiates a new <see cref="global::Immich.Models.SystemConfigFFmpegDto"/> and sets the default values.
        /// </summary>
        public SystemConfigFFmpegDto()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Immich.Models.SystemConfigFFmpegDto"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::Immich.Models.SystemConfigFFmpegDto CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
            return new global::Immich.Models.SystemConfigFFmpegDto();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "accel", n => { Accel = n.GetEnumValue<global::Immich.Models.TranscodeHWAccel>(); } },
                { "accelDecode", n => { AccelDecode = n.GetBoolValue(); } },
                { "acceptedAudioCodecs", n => { AcceptedAudioCodecs = n.GetCollectionOfEnumValues<global::Immich.Models.AudioCodec>()?.AsList(); } },
                { "acceptedContainers", n => { AcceptedContainers = n.GetCollectionOfEnumValues<global::Immich.Models.VideoContainer>()?.AsList(); } },
                { "acceptedVideoCodecs", n => { AcceptedVideoCodecs = n.GetCollectionOfEnumValues<global::Immich.Models.VideoCodec>()?.AsList(); } },
                { "bframes", n => { Bframes = n.GetIntValue(); } },
                { "cqMode", n => { CqMode = n.GetEnumValue<global::Immich.Models.CQMode>(); } },
                { "crf", n => { Crf = n.GetIntValue(); } },
                { "gopSize", n => { GopSize = n.GetIntValue(); } },
                { "maxBitrate", n => { MaxBitrate = n.GetStringValue(); } },
                { "preferredHwDevice", n => { PreferredHwDevice = n.GetStringValue(); } },
                { "preset", n => { Preset = n.GetStringValue(); } },
                { "refs", n => { Refs = n.GetIntValue(); } },
                { "targetAudioCodec", n => { TargetAudioCodec = n.GetEnumValue<global::Immich.Models.AudioCodec>(); } },
                { "targetResolution", n => { TargetResolution = n.GetStringValue(); } },
                { "targetVideoCodec", n => { TargetVideoCodec = n.GetEnumValue<global::Immich.Models.VideoCodec>(); } },
                { "temporalAQ", n => { TemporalAQ = n.GetBoolValue(); } },
                { "threads", n => { Threads = n.GetIntValue(); } },
                { "tonemap", n => { Tonemap = n.GetEnumValue<global::Immich.Models.ToneMapping>(); } },
                { "transcode", n => { Transcode = n.GetEnumValue<global::Immich.Models.TranscodePolicy>(); } },
                { "twoPass", n => { TwoPass = n.GetBoolValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
            writer.WriteEnumValue<global::Immich.Models.TranscodeHWAccel>("accel", Accel);
            writer.WriteBoolValue("accelDecode", AccelDecode);
            writer.WriteCollectionOfEnumValues<global::Immich.Models.AudioCodec>("acceptedAudioCodecs", AcceptedAudioCodecs);
            writer.WriteCollectionOfEnumValues<global::Immich.Models.VideoContainer>("acceptedContainers", AcceptedContainers);
            writer.WriteCollectionOfEnumValues<global::Immich.Models.VideoCodec>("acceptedVideoCodecs", AcceptedVideoCodecs);
            writer.WriteIntValue("bframes", Bframes);
            writer.WriteEnumValue<global::Immich.Models.CQMode>("cqMode", CqMode);
            writer.WriteIntValue("crf", Crf);
            writer.WriteIntValue("gopSize", GopSize);
            writer.WriteStringValue("maxBitrate", MaxBitrate);
            writer.WriteStringValue("preferredHwDevice", PreferredHwDevice);
            writer.WriteStringValue("preset", Preset);
            writer.WriteIntValue("refs", Refs);
            writer.WriteEnumValue<global::Immich.Models.AudioCodec>("targetAudioCodec", TargetAudioCodec);
            writer.WriteStringValue("targetResolution", TargetResolution);
            writer.WriteEnumValue<global::Immich.Models.VideoCodec>("targetVideoCodec", TargetVideoCodec);
            writer.WriteBoolValue("temporalAQ", TemporalAQ);
            writer.WriteIntValue("threads", Threads);
            writer.WriteEnumValue<global::Immich.Models.ToneMapping>("tonemap", Tonemap);
            writer.WriteEnumValue<global::Immich.Models.TranscodePolicy>("transcode", Transcode);
            writer.WriteBoolValue("twoPass", TwoPass);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
